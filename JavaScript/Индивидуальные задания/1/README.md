# DPLL SAT солвер

### SAT ([Википедия](https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D0%B4%D0%B0%D1%87%D0%B0_%D0%B2%D1%8B%D0%BF%D0%BE%D0%BB%D0%BD%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D0%B8_%D0%B1%D1%83%D0%BB%D0%B5%D0%B2%D1%8B%D1%85_%D1%84%D0%BE%D1%80%D0%BC%D1%83%D0%BB#%D0%92%D1%8B%D1%87%D0%B8%D1%81%D0%BB%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F_%D1%81%D0%BB%D0%BE%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D1%8C))
> Задача выполнимости булевых формул (SAT) — важная для теории вычислительной сложности алгоритмическая задача. Экземпляром задачи является булева формула, состоящая только из имён переменных, скобок и операций $\wedge$ (И), $\vee$  (ИЛИ) и $\neg$  (HE). Задача заключается в следующем: можно ли назначить всем переменным, встречающимся в формуле, значения ложь и истина так, чтобы формула стала истинной.

### DPLL ([Википедия](https://ru.wikipedia.org/wiki/DPLL#%D0%A0%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8_%D0%B8_%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F))
>DPLL (алгоритм Дэвиса — Патнема — Логемана — Лавленда) — полный алгоритм поиска с возвратом для решения задачи CNF-SAT — определения выполнимости булевых формул, записанных в конъюнктивной нормальной форме.

>Основной алгоритм с возвратом начинается с выбора переменной, присвоения ей значения «истина», упрощения формулы и затем рекурсивным образом проверки упрощенной формулы на выполнимость; если она выполнима, то исходная формула тоже выполнима; иначе, процедура повторяется, но выбранной переменной задается значение «ложь». Этот подход называется «правилом разбиения», так как он разбивает задачу на две более простые подзадачи. Шаг упрощения заключается в том, что из формулы удаляются все дизъюнкты, которые становятся истинными после присвоения выбранной переменной значения «истина» и удаления из оставшихся дизъюнкт всех вхождений этой переменной, которые становятся ложными.

### Входные данные
Программа принимает булевую функцию в формате 
```
(A+B)(!A)(!B+!C+D)
```
Переменные должны задаваться буквами английского алфавита, скобки для разделения дизъюнктов обяхательны, логическое "или" записывается как "+", логическое "не" - как "!", логическое "и" пропускается.

### Примеры работы

#### Input:
```
(A+B)(!A)(C)(A+C)(E+F)(!E)
````

#### Output:

```
РАЗРЕШИМО ПРИ
A => false
B => true
C => true
E => false
F => true
```

#### Input:
```
(A+B)(!A)(C)(A+C)(E+F)(!E)(!F)
````

#### Output:

```
НЕРАЗРЕШИМО
```

### Реализация
Функции ```toDisjunctive(...)``` и ```getElements(...)``` преобразуют изначальную строку в массив дизъюнктов и, соответственно, дизъюнкт в массив слагаемых. Функция ```newUnit(...)``` анализирует дизъюнк при заданном значении какой-то переменной и либо возвращает его значение (true/false), либо сокращенный вид, т.е. без этой переменной. Функция ```insertVal(...)``` для заданного значения какой-то переменной и набора дизъюнктов вызывает функцию ```newUnit(...)``` для каждого из них и анализирует результат. Функция ```getLetter(...)``` на основе дизъюнкта возвращает имя первой встреченной переменной. Функция ```DPLL``` для набора дизъюнктов выбирает через ```getLetter(...)``` переменную, вызывает ```insertVal(...)``` для этого же набора при значении выбранной переменной - true, а затем - false, и анализирует результаты. В итоге либо после полного перебора всех значений всех переменных мы придем к тому, сто формула неразрешима, либо мы в определенный момент остановимся, в таком случае на экран выведутся значения тех переменных, которые использовались. Если в формуле использовались какие-то еще переменные, то их значение может быть выбрано произвольно. Данные хранятся в словаре, где ключ - имя переменной, значение - true/false - выбранное значение данной переменной.
